import argparse
from collections import defaultdict
from typing import Union, Tuple, List, Literal
import os
import re
import random
import pandas as pd
from loguru import logger
from gtfhandle.utils import fasta_to_dict
from mutsplice.datasets.manage_spliceai import _process_ss_idx


class MotifsHits(object):
    """
    Representation of Motif scanned files
    """

    def __init__(self, file: str,
                 file_format: str = Literal['fimo', 'plain']):
        """
        Reads output files from the
        motif scanning tool

        :param str file: File from motif
        scanning tool
        :param str file_format: Format of the output of
        the motif scanning step. Default: `fimo`
        """
        self.file = file
        
        if file_format == "fimo":
            self.motif_matches = self._parse_fimo_tsv()
            self.from_fimo = True
            
        elif file_format == "plain":
            self.motif_matches = self._parse_plain_search()
            self.from_fimo = False

    def _parse_plain_search(self) -> defaultdict(list):
        """
        Parses TSV file generated by `motif_scanning`
        script.

        :return defaultdict: Processed dict
        """
        out = defaultdict(list)
        df = pd.read_csv(self.file, sep="\t")

        # cols = ['seq_id', 'rbp_name', 'rbp_name_motif', 'Start', 'End', 'rbp_motif',
        #         'has_self_submotif', 'has_other_submotif', 'is_high_density_region', 
        #         'n_at_density_block']

        #df = df[cols]

        lists = df.values.tolist()
        [out[row[0]].append(row[1:]) for row in lists]
        return out

    def _parse_fimo_tsv(self) -> defaultdict(list):
        """
        Parses TSV file outputted by FIMO
        into a dictionary

        :return defaultdict: Processed dict
        """
        out = defaultdict(list)
        df = pd.read_csv(self.file, comment="#", sep="\t")

        cols = ['sequence_name', 'motif_alt_id', 'motif_id', 'start',
                'stop', 'matched_sequence']

        df = df[cols]
        lists = df.values.tolist()
        [out[row[0]].append(row[1:]) for row in lists]
        return out


class MutateSequences(object):
    """
    Class to mutate DNA/RNA sequences
    in a defined manner
    """

    def __init__(self,
                 fasta: str,
                 outdir: str,
                 outbasename: str,
                 motifs: MotifsHits = None,
                 ss_idx: str = None,
                 ss_idx_extend: int = 5000,
                 ss_idx_skip_ssRegion: bool = False):
        """
        :param str fasta: Fasta file to mutate
        :param str outbasename: Output basename
        :param MotifsHits motifs: Motif object with a defaultdict of
        motif matches as an attibute. Default: `None`.
        :param str ss_idx: File with indexes of splice sites
        for each of the input sequences. If set, mutations
        will be generated in the regions surrounding the indexes
        of cassette exons
        :param int ss_idx_extend: Number of basepairs extending
        from exon splice sites that are available to be mutated.
        Default: `5000`.
        :param bool ss_idx_skip_ssRegion: Skip mutating sequences
        at near splice site regions when 'ss_idx' is provided.
        """
        logger.log("MAIN", "Generating mutations")
        self.fasta = os.path.basename(fasta)
        self.seqs = fasta_to_dict(fasta)

        self.outbasename = outbasename
        os.makedirs(outdir, exist_ok=True)
        self.outdir = outdir

        self.motifs = None if motifs is None else motifs.motif_matches
        self.ss_idx_extend = ss_idx_extend
        self.ss_idx_skip_ssRegion = ss_idx_skip_ssRegion

        if ss_idx:
            self.ss_idx, _ = _process_ss_idx(self.seqs, ss_idx)

            # Remove motif matches outside of the sequence scope
            if self.motifs:
                self._restrict_mutagenesis_space()
        else:
            self.ss_idx = None

    def _restrict_mutagenesis_space(self):
        """
        Restrict the mutagenesis space in
        a given set of sequences by making
        use of boundaries so that motifs
        hits assigned to be mutated will be
        ignored.

        :return dict: Updated motif hits to be mutated
        """

        for seq_id in self.motifs.keys():

            cassette_idx = self.ss_idx[seq_id][1]
            region_from_accept = max(cassette_idx[0] - self.ss_idx_extend, 0)
            region_from_donor = cassette_idx[1] + self.ss_idx_extend 

            hits_at_seq = self.motifs[seq_id]
            _n = len(hits_at_seq)

            self.motifs[seq_id] = [m for m in hits_at_seq if m[2] >= region_from_accept
                                   and m[3] <= region_from_donor]

            if self.ss_idx_skip_ssRegion:
                accept_ups_10bp = max(cassette_idx[0] - 5, 0)
                donor_down_10bp = max(cassette_idx[1] + 5, 0)
                # logger.debug("Intermediary number of motifs: {}".format(len(self.motifs[seq_id])))

                self.motifs[seq_id] = [m for m in self.motifs[seq_id] if
                                       not (accept_ups_10bp <= m[2] <= cassette_idx[0] and
                                            accept_ups_10bp <= m[3] <= cassette_idx[0] and
                                            donor_down_10bp <= m[2] <= cassette_idx[1] and
                                            donor_down_10bp <= m[3] <= cassette_idx[1])]

            logger.debug("Motifs in sequence {} removed "
                         "after restricting mutagenesis "
                         "space: {}".format(seq_id, _n - len(self.motifs[seq_id])))


class MutateAtMotifLocation(MutateSequences):
    """
    Mutate sequences at motif positions provided
    """

    def __init__(self,
                 fasta: str,
                 motifs: MotifsHits,
                 outdir: str,
                 outbasename: str,
                 ss_idx: str = None,
                 ss_idx_extend: int = 5000,
                 ss_idx_skip_ssRegion: bool = False,
                 n_mutations: int = 1,
                 abrogate: bool = False):
        """
        :param int n_mutations: Number of
        mutations to create at each motif
        location. Default : `1`.
        :param bool abrogate: Completely
        remove motif from the sequences.
        Default: `False`
        """

        assert 0 < n_mutations < 5, "Number of mutations per motif " \
                                    "location must be between 1 and 5"

        super().__init__(fasta=fasta,
                         outdir=outdir,
                         outbasename=outbasename,
                         motifs=motifs,
                         ss_idx=ss_idx,
                         ss_idx_extend=ss_idx_extend,
                         ss_idx_skip_ssRegion=ss_idx_skip_ssRegion)

        self.from_fimo = motifs.from_fimo
        self.n_mutations = n_mutations
        self.abrogate = abrogate

    def mutateMotifs(self):
        """
        Create mutations given a set of
        sequences and motif locations found by
        motif scanning tool

        :param dict fasta: Fasta seqs
        motif scanning run
        :return:
        """

        logger.info('Number of seqs in {} file: {}'.format(
            self.fasta, len(self.seqs)))
        out_path = os.path.join(self.outdir, self.outbasename)
        if os.path.exists(out_path + '_all_metadata.tsv'):
            os.remove(out_path + '_all_metadata.tsv')

        for seq_id, motif_pos in self.motifs.items():
            
            logger.debug('Number of motif locations to mutate in {} seq: {}'.format(
                seq_id, len(motif_pos)))
            id_ = re.sub('\([+-]\)', '', seq_id)

            if seq_id not in self.seqs.keys():
                continue

            output_file = out_path + "_" + id_ + ".fa"
            out_handle = open(output_file, 'w')
            out_handle.write('>{}_REF_seq\n{}\n'.format(
                seq_id, self.seqs[seq_id]))
            
            output_seqs, _metadata = self._call(self.seqs[seq_id], motif_pos, seq_id)

            cols = ['id', 'seq_id', 'rbp_name', 'start',
                    'end', 'mutation', 'type',
                    'motif_start', 'motif_end']

            metadata = pd.DataFrame.from_records(_metadata, columns=cols)
            metadata = metadata.dropna(axis=1, how='all')      
            metadata.to_csv(out_path + '_all_metadata.tsv',
                            sep='\t', index=False, mode='a',
                            header=not os.path.exists(out_path + '_all_metadata.tsv'))

            for k, v in output_seqs.items():
                out_handle.write('>{}\n{}\n'.format(k, v))

    def _call(self,
              seq: str,
              motif_positions: List,
              seq_id: str):
        """
        Given an input seq, mutate at given sequence indexes
        :param str seq: Sequence
        :param List motif_positions: Motif positions
        :param str seq_id: Sequence ID
        :return dict:
        """
        motif_mutated = {}
        metadata = []

        for _, m in enumerate(motif_positions):
    
            rbp_name = m[0]
            m_start = m[2]
            m_end = m[3]
         
            fixed_seq_left = seq[:m_start]
            fixed_seq_right = seq[m_end:]

            if self.abrogate:
                key = '{}_DEL_{}_{}'.format(seq_id, m_start, m_end)
                if key not in motif_mutated:
                    motif_mutated[key] = fixed_seq_left + fixed_seq_right

                res = [key, seq_id, rbp_name, m_start, m_end,
                       seq[m_start:m_end], "DEL", m_start, m_end]

                metadata.append(res)

            elif self.n_mutations == 1:
    
                _motif_mutated, _metadata = self.ism(seq[m_start:m_end],
                                                     seq_id,
                                                     start=m_start,
                                                     end=m_end,
                                                     extra="motif_at_pos_" +
                                                           str(m_start) + "_" +
                                                           str(m_end))

                [x.insert(2, rbp_name) for x in _metadata]
                metadata.extend(_metadata)

                for k, _seq in _motif_mutated.items():
                    if k not in motif_mutated:
                        motif_mutated[k] = fixed_seq_left + _seq + fixed_seq_right
          
        return motif_mutated, metadata

    def ism(self, seq: str,
            seq_id: str,
            start: int = None,
            end: int = None,
            extra: str = "") -> Tuple[Union[list, dict], list]:
        """
        Do in silico mutagenesis for an input seq

        :param str seq: Input sequence
        :param str seq_id: Sequence id
        :param int start: Start position of seq
        in a larger seq.
        :param int end: End positions of seq
        in a larget seq.
        :param str extra: Extra string to add on
        the annotation
        :return list:
        """
        map = {'A': ['C', 'G', 'T'],
               'C': ['A', 'G', 'T'],
               'G': ['A', 'C', 'T'],
               'T': ['A', 'C', 'G']}

        output = {}
        metadata = []

        for i, nuc in enumerate(seq):

            for subst in map[nuc]:
                _mutated = seq[:i] + subst + seq[i + 1:]
                header = extra if extra else ""

                if header:
                    header += "_" + nuc + '_subs_by_' + subst + "_at_" + str(i)
                else:
                    header = nuc + '_subs_by_' + subst + "_at_" + str(i)

                key = seq_id + "_" + header
                output[key] = _mutated
                if start and end:
                    metadata.append(
                        [key, seq_id, start + i, start + i, subst, 'SNV', start, end])
                else:
                    metadata.append([key, seq_id, i, i, subst, 'SNV'])

        return output, metadata


class MutateOverSequences(MutateSequences):
    """
    Mutate over a set of sequences
    """

    def __init__(self,
                 fasta: str,
                 outdir: str,
                 outbasename: str,
                 motifs: Union[List, MotifsHits] = None,
                 ss_idx: str = None,
                 ss_idx_extend: int = 5000,
                 ss_idx_skip_ssRegion: bool = False,
                 exclude_idx: List[int] = None,
                 sample_n: int = None):
        """
        :param List[int] exclude_idx: Avoid creating
        mutations between the indexes represented in
        the list

        :param int: Sample N positions from the sequence
        to mutate
        """
        if exclude_idx:
            assert len(
                exclude_idx) == 2, "Length of the exclude_idx args must be 2"
        self.exclude_idx = exclude_idx
        self.sample_n = sample_n

        super().__init__(fasta=fasta,
                         outdir=outdir,
                         outbasename=outbasename,
                         motifs=motifs,
                         ss_idx=ss_idx,
                         ss_idx_extend=ss_idx_extend,
                         ss_idx_skip_ssRegion=ss_idx_skip_ssRegion)

    def mutate_over_a_seq(self):
        """
        Create single point mutations on a
        given set of sequences

        :param dict d: Dictionary with fasta
        headers as keys and sequences to
        mutate as values
        """

        logger.info('Number of seqs in {} file: {}'.format(
            self.fasta, len(self.seqs)))
        out_path = os.path.join(self.outdir, self.outbasename)
        if os.path.exists(out_path + '_all_metadata.tsv'):
            os.remove(out_path + '_all_metadata.tsv')

        for _header, seq in self.seqs.items():
            id_ = _header.split("(")[0]
            output_file = out_path + "_" + id_ + ".fa"
            out_handle = open(output_file, 'w')
            out_handle.write('>{}_REF_seq\n{}\n'.format(
                _header, self.seqs[_header]))

            if self.exclude_idx:
                output_seqs, _metadata = self._mutate_excluding_some_index(
                    seq, _header)

            else:
                output_seqs, _metadata = self.ism(seq, seq_id=_header)

            metadata = pd.DataFrame.from_records(_metadata, columns=['id', 'seq_id', 'start', 'end',
                                                                     'mutation', 'type'])
            metadata.to_csv(out_path + '_all_metadata.tsv',
                            sep='\t', index=False, mode='a',
                            header=not os.path.exists(out_path + '_all_metadata.tsv'))

            for k, v in output_seqs.items():
                out_handle.write('>{}\n{}\n'.format(k, v))

    def _mutate_excluding_some_index(self,
                                     seq: str,
                                     _header: str):
        """
        Mutate sequence taking into account
        a range of indexes that must remain
        unchanged.

        :param str seq: Sequence to mutate
        :param str _header: Header
        """

        start_idx = self.exclude_idx[0]
        end_idx = self.exclude_idx[1]

        assert end_idx > start_idx, "--exclude_idx problem: End index must be higher than start index"
        assert start_idx > 0, "--exclude_idx problem: Start index must be higher than 0"

        len_excluded_idx = end_idx - start_idx
        to_mutate_left = seq[:start_idx]
        to_mutate_right = seq[end_idx:]

        if self.sample_n:

            self.sample_n //= 2
            assert len(to_mutate_left) > self.sample_n, "Number of available nucleotides " \
                                                        "upstream of the '--exclude_idx' " \
                                                        "provided ({}) is lower than the " \
                                                        "number of desired positions to " \
                                                        "sample on that side ({}).".format(len(to_mutate_left),
                                                                                           self.sample_n)

            assert len(to_mutate_right) > self.sample_n, "Number of available nucleotides " \
                                                         "downstream of the '--exclude_idx' " \
                                                         "provided ({}) is lower than the " \
                                                         "number of desired positions to " \
                                                         "sample ({}) on that side.".format(len(to_mutate_right),
                                                                                            self.sample_n)

        left_mutated, metadata_l = self.ism(to_mutate_left,
                                            seq_id=_header)

        right_mutated, metadata_r = self.ism(to_mutate_right,
                                             seq_id=_header,
                                             sum_to_idx=len(to_mutate_left) + len_excluded_idx)

        to_keep = seq[start_idx:end_idx]

        for k, v in left_mutated.items():
            left_mutated[k] = v + to_keep + to_mutate_right

        for k, v in right_mutated.items():
            right_mutated[k] = to_mutate_left + to_keep + v

        all_seqs = {**left_mutated, **right_mutated}
        all_metadata = metadata_l + metadata_r
        return all_seqs, all_metadata

    def ism(self, seq: str,
            seq_id: str,
            sum_to_idx: int = None,
            extra: str = None) -> Tuple[Union[list, dict], list]:
        """
        Do single nucleotide substitutions in a given
        input sequence

        :param str seq: Input sequence
        :param str seq_id: Sequence header
        :param str extra: Extra string to add on
        the annotation
        :param int sum_to_idx: Sum this number of
        positions to the seq index when writing the
        metadata (e.g. useful when seq represents a
        sub sequence that was excluded from mutagenesis
        and we wish to know the overall index mutated in
        respect to the full sequence)

        :return list:
        """
        map = {'A': ['C', 'G', 'T'],
               'C': ['A', 'G', 'T'],
               'G': ['A', 'C', 'T'],
               'T': ['A', 'C', 'G']}

        output = {}
        metadata, sampled_idx = [], []

        if self.sample_n is not None:

            sampled_idx = sorted(random.sample(
                range(0, len(seq)), self.sample_n))

        for i, nuc in enumerate(seq):

            if sampled_idx and i not in sampled_idx:
                continue

            for subst in map[nuc]:

                _mutated = seq[:i] + subst + seq[i + 1:]
                _i = i + sum_to_idx if sum_to_idx else i
                header = extra if extra else ""

                if header:
                    header += "_" + nuc + '_subs_by_' + \
                        subst + "_at_" + str(_i)
                else:
                    header = nuc + '_subs_by_' + subst + "_at_" + str(_i)

                key = seq_id + "_" + header
                output[key] = _mutated
                metadata.append([key, seq_id, _i, _i, subst, 'SNV'])

        return output, metadata
